import * as fs from "fs";
import * as path from "path";

/**
 * Ermittelt den TypeScript-Typ eines Wertes.
 */
function resolveType(value: any): string {
  if (value === null) return "any";
  if (Array.isArray(value)) {
    if (value.length === 0) return "any[]";
    return `${resolveType(value[0]).replace(/\[\]$/, "")}[]`;
  }
  switch (typeof value) {
    case "string": return "string";
    case "number": return "number";
    case "boolean": return "boolean";
    case "object":
      if (!value) return "any";
      const entries = Object.entries(value)
        .map(([k, v]) => `${k}: ${resolveType(v)}`)
        .join("; ");
      return `{ ${entries} }`;
    default:
      return "any";
  }
}

/**
 * Very annoying long comment that will be injected into every generated file.
 * It's intentionally repetitive and verbose to be as "nervig" as requested.
 *
 *  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
 *  WARNING: THIS FILE IS GENERATED AUTOMATICALLY.
 *  DO NOT EDIT THIS FILE DIRECTLY UNLESS YOU ABSOLUTELY KNOW WHAT YOU ARE DOING.
 *  ANY MANUAL CHANGES MAY BE OVERWRITTEN BY InterfaceSniper.
 *  This comment is intentionally long and repetitive to annoy and inform.
 *
 *  - Generated by: InterfaceSniper
 *  - Purpose: Representation of the runtime object shape as a TypeScript interface
 *  - Timestamp: {TIMESTAMP}   <-- will be replaced at generation time
 *
 *  Seriously, STOP editing. If you must change something, change the source code
 *  that produces the object or adjust the InterfaceSniper decorator usage.
 *
 *  This header will appear in every generated file. It is long. It is extra. It is annoying.
 *  Repeat after me: "I understand that this file is generated and may be overwritten."
 *
 *  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
 */

/**
 * Erzeugt den nervigen Header-String mit aktuellem Timestamp.
 */
function annoyingHeader(): string {
  const ts = new Date().toISOString();
  const header = `/**
 * ================================================================
 * IMPORTANT GENERATED FILE â€” InterfaceSniper
 * ================================================================
 * DO NOT EDIT THIS FILE MANUALLY.
 * THIS FILE IS GENERATED. CHANGES WILL BE LOST.
 *
 * Generated at: ${ts}
 *
 * This file contains a TypeScript interface automatically created by
 * InterfaceSniper. It represents the runtime shape of an object.
 *
 * If you keep editing this file by hand, the next run of the generator
 * may overwrite your edits. Please edit the source instead.
 *
 * (This comment is intentionally long, repetitive and slightly annoying.)
 *
 * ================================================================
 */\n\n`;
  return header;
}

/**
 * Generiert eine TypeScript-Interface-Datei aus einem Objekt.
 * - Ã¼berschreibt die Datei nur, wenn debugMode === true
 */
function generateInterface(obj: Record<string, any>, interfaceName: string, outFile: string, debugMode: boolean) {
  if (!obj || typeof obj !== "object") return;

  const interfaceBody = Object.entries(obj)
    .map(([key, value]) => `  ${key}: ${resolveType(value)};`)
    .join("\n");

  const interfaceDef = `${annoyingHeader()}export interface ${interfaceName} {\n${interfaceBody}\n}\n`;

  // Datei existiert?
  const exists = fs.existsSync(outFile);

  if (exists && !debugMode) {
    console.log(`ðŸ“Œ InterfaceSniper: Datei existiert bereits und debugMode=false â†’ nicht Ã¼berschrieben: ${outFile}`);
    return;
  }

  // Ordner erstellen, falls nicht vorhanden
  fs.mkdirSync(path.dirname(outFile), { recursive: true });

  // Schreiben (Ã¼berschreibt wenn debugMode true oder Datei nicht existiert)
  fs.writeFileSync(outFile, interfaceDef, { encoding: "utf8" });

  console.log(`${exists ? (debugMode ? "ðŸ” Interface (Ã¼berschrieben)" : "ðŸ“Œ Interface (nicht Ã¼berschrieben)") : "ðŸ“„ Interface (neu)"} ${interfaceName} geschrieben nach ${outFile}`);
}

/**
 * Ermittelt das Verzeichnis der Datei, die den Decorator aufruft
 */
function getCallerDir(): string {
  const orig = Error.prepareStackTrace;
  Error.prepareStackTrace = (_, stack) => stack;
  const err = new Error();
  const stack = err.stack as unknown as NodeJS.CallSite[] | undefined;
  Error.prepareStackTrace = orig;

  // Stack layout: [getCallerDir, InterfaceSniper decorator factory/wrapper, decorated function caller]
  const callerFile = stack?.[2]?.getFileName() || stack?.[3]?.getFileName();
  if (!callerFile) return process.cwd();
  return path.dirname(callerFile);
}

/**
 * Bestimmt, ob Debug-Modus aktiv ist.
 * - true, wenn process.env.DEBUG === 'true' oder process.env.NODE_ENV === 'development'
 */
function isDebugMode(): boolean {
  const d = (process.env.DEBUG || "").toLowerCase();
  const nodeEnv = (process.env.NODE_ENV || "").toLowerCase();
  return d === "true" || nodeEnv === "development";
}

/**
 * Method-Decorator: erzeugt ein Interface fÃ¼r den RÃ¼ckgabewert der Methode.
 * @param interfaceName Name des Interfaces
 * @param outFile Pfad zur TS-Datei (relativ zur aufrufenden Datei â†’ wird in <callerDir>/sniped/<outFile> gespeichert,
 *                oder absolut, wenn ein absoluter Pfad angegeben wird)
 */
export function InterfaceSniper(interfaceName: string, outFile?: string): MethodDecorator {
  return (
    target: Object,
    propertyKey: string | symbol,
    descriptor: PropertyDescriptor
  ): void => {
    if (!descriptor || typeof descriptor.value !== "function") {
      throw new Error("@InterfaceSniper kann nur auf Methoden angewendet werden!");
    }

    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
      try {
        const maybePromise = originalMethod.apply(this, args);

        const writeInterface = (result: any) => {
          try {
            if (!result || typeof result !== "object") {
              // nichts zu tun
              return;
            }

            const debug = isDebugMode();

            if (!outFile)
              outFile = interfaceName + ".interface.ts"

            const resolved = path.isAbsolute(outFile)
              ? outFile
              : path.resolve(getCallerDir(), "sniped", outFile);

            generateInterface(result, interfaceName, resolved, debug);
          } catch (e) {
            console.error("InterfaceSniper: Fehler beim Erstellen der Interface-Datei:", e);
          }
        };

        if (maybePromise && typeof maybePromise.then === "function") {
          return maybePromise.then((res: any) => {
            writeInterface(res);
            return res;
          });
        } else {
          writeInterface(maybePromise);
          return maybePromise;
        }
      } catch (e) {
        throw e;
      }
    };
  };
}
